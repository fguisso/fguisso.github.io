---
title: "CodeQL <span>vs</span> Joern"
date: "2025-08-20"
description: "Uma comparação técnica detalhada entre as ferramentas de análise estática de código CodeQL e Joern, abordando funcionamento interno, linguagens suportadas, desempenho, usabilidade e integração com CI/CD."
tags: ["codeql", "joern", "sast", "security", "static analysis"]
categories: ["Security"]
---

# Comparação Técnica: CodeQL vs Joern

## Funcionamento Interno das Ferramentas

**CodeQL:** Internamente, o CodeQL extrai a base de código para uma representação relacional e armazena tudo em um _database_ específico por linguagem. Para linguagens compiladas (como C/C++, Java, C# etc.), ele monitora o processo de compilação: a cada invocação do compilador, o CodeQL coleta informações sintáticas (AST) e semânticas (nomes, tipos, etc.) e grava esses dados no banco de dados CodeQL[\[1\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=On%20the%20one%20hand%2C%20CodeQl,for%20further%20processing%20and%20querying)[\[2\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=For%20compiled%20languages%2C%20extraction%20works,name%20binding%20and%20type%20information). Ou seja, é necessário **compilar ou construir** o projeto para gerar a base de dados. Essa base contém tabelas representando elementos do código (expressões, instruções, fluxos de dados e controle, etc.), seguindo um esquema específico de acordo com a linguagem[\[3\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=CodeQL%20databases%20contain%20queryable%20data,and%20the%20control%20flow%20graph)[\[4\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=For%20each%20language%2C%20the%20CodeQL,it%20easier%20to%20write%20queries). Após a extração, as consultas (queries) são executadas sobre esse banco de dados para encontrar padrões ou possíveis vulnerabilidades[\[5\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=After%20you%E2%80%99ve%20created%20a%20CodeQL,36%20CodeQL%20for%20VS%20Code). Em resumo, o CodeQL primeiro prepara um banco de dados de código e depois roda consultas otimizadas nesse banco, retornando resultados interpretados com localização no código fonte[\[6\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=language%20called%20QL,%E2%80%9D)[\[7\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=designed%20to%20find). Esse design baseado em banco relacional permite análises complexas com otimizações similares a consultas SQL/Datalog sob o capô[\[8\]](https://blog.xaviermaso.com/2024/08/14/Solving-LinkedIn's-Queens-game-with-CodeQL.html#:~:text=blog%20blog,used%20as%20a%20query).

**Joern:** O Joern adota uma abordagem bem diferente. Ele **não requer a compilação** do código fonte; em vez disso, utiliza _parsers_ próprios (ou frontends específicos) com parsing tolerante (“_fuzzy parsing_”) para construir um **Code Property Graph (CPG)** do programa[\[9\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=With%20a%20completely%20different%20perspective%2C,memory). O CPG é uma estrutura de grafo que combina múltiplas representações clássicas do programa – incluindo a árvore de sintaxe abstrata (AST), o grafo de fluxo de controle (CFG) e o grafo de dependência de dados (DDG) – em um único grafo unificado[\[10\]](https://docs.joern.io/code-property-graph/#:~:text=,flow.). Cada nó do grafo representa um elemento do código (como método, variável, instrução, etc.) e carrega atributos, e as arestas (dirigidas e rotuladas) representam relações como “contém”, “chama”, “fluxo de dados”, etc.[\[11\]](https://docs.joern.io/code-property-graph/#:~:text=,declaration%20of%20a%20local%20variable)[\[12\]](https://docs.joern.io/code-property-graph/#:~:text=%2A%20Key,type%20of%20the%20declared%20variable). O Joern armazena esse grafo em um banco de dados de grafos em memória (nas versões recentes, utiliza o _OverflowDB_, substituindo backends como Neo4j usados em versões antigas)[\[13\]](https://docs.joern.io/code-property-graph/#:~:text=Property%20graphs%20are%20a%20generic,our%20own%20graph%20database%20OverflowDB). Assim, o funcionamento interno do Joern consiste em parsear o código (mesmo projetos parcialmente incompletos) e **popular um grafo** que une diversas visões do programa, sobre o qual as consultas de análise serão realizadas[\[9\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=With%20a%20completely%20different%20perspective%2C,memory). Em essência, o CodeQL modela o código como tabelas relacionais, enquanto o Joern modela como um grafo de propriedades – duas abordagens distintas para representar e consultar o código fonte.

## Linguagem de Consulta e Expressividade

**CodeQL (QL):** A linguagem de consulta do CodeQL chama-se **QL**. É uma linguagem declarativa, inspirada em lógica/Datalog e com recursos de orientação a objetos, projetada especificamente para análise de código[\[14\]](https://www.tesena.com/en/find-vulnerabilities-in-your-code-with-codeql/a-481/#:~:text=that%20triggered%20the%20alert%2C%20GitHub,automatically%20closes%20the%20alert). Uma consulta CodeQL tipicamente define classes ou predicados que representam elementos do código (por exemplo, uma classe Function que representa funções no código) e utiliza construções como from ... where ... select ... para recuperar padrões desejados. A sintaxe lembra SQL em alguns aspectos, porém a semântica é lógica – o desenvolvedor declara condições que os resultados devem satisfazer, e o motor do CodeQL lida com as junções e otimizações necessárias[\[8\]](https://blog.xaviermaso.com/2024/08/14/Solving-LinkedIn's-Queens-game-with-CodeQL.html#:~:text=blog%20blog,used%20as%20a%20query). O poder expressivo é **alto**: é possível navegar por relações estruturais (AST), fluxo de controle e até fluxo de dados usando bibliotecas fornecidas. Por exemplo, o CodeQL inclui bibliotecas de **fluxo de dados e rastreamento de “taint”** (_TaintTracking_), permitindo escrever consultas que seguem variáveis de fontes não confiáveis até possíveis pontos de uso sensíveis[\[15\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=is%20to%20find%20all%20the,overflowing%20memory%20access%20uses%20a)[\[16\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=Here%2C%20I%20show%20the%20query,written%20for%20CodeQl). A curva de aprendizado do QL pode ser íngreme para iniciantes, pois envolve conceitos de lógica declarativa e conhecimento das bibliotecas padrão de cada linguagem. Entretanto, a documentação oficial é extensa e existem tutoriais, exemplos e até desafios CTF do Security Lab para ensinar como escrever consultas CodeQL[\[17\]\[18\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=,world%20codebases). Na prática, muitos casos de uso comuns (por exemplo, “encontrar chamadas de função X com argumento perigoso Y”) já são cobertos por exemplos nas bibliotecas padrão, facilitando a vida do analista.

**Joern (CPG Query Language):** As consultas no Joern são escritas em uma DSL (_Domain-Specific Language_) baseada em Scala[\[19\]](https://docs.joern.io/code-property-graph/#:~:text=The%20code%20property%20graph%20is,and%20its%20commercial%20brother%20Ocular). Diferentemente de uma linguagem puramente declarativa, aqui o usuário realiza **percursos (traversals) no grafo** representando o código. O ponto de partida é geralmente o objeto raiz cpg (Code Property Graph), a partir do qual existem métodos encadeáveis que filtram e navegam pelos nós e arestas do grafo. Por exemplo, uma consulta simples para listar nomes de métodos é: cpg.method.name.toList[\[20\]](https://docs.joern.io/traversal-basics/#:~:text=As%20an%20example%2C%20the%20query). Nessa query, cpg é a raiz, method seleciona todos nós de tipo método, name acessa a propriedade nome de cada nó, e toList executa a consulta retornando uma lista de resultados[\[20\]](https://docs.joern.io/traversal-basics/#:~:text=As%20an%20example%2C%20the%20query). A DSL oferece diversos “_steps_” e filtros: nodeType steps (como method, file, call etc.), filtros (.filter(...), .where(...) com predicados em Scala), passos de controle de fluxo e de fluxo de dados pré-definidos (por exemplo, .reachableBy(...) para navegar por arestas de dependência de dados)[\[21\]](https://joern.io/automate/#:~:text=val%20src%20%3D%20cpg.call%28,hasNext)[\[22\]](https://joern.io/automate/#:~:text=.call%28,hasNext). Na prática, escrever consultas Joern muitas vezes se assemelha a escrever código Scala encadeando operações de grafo. A **expressividade** também é alta – é possível atravessar do nó de uma função para os literais usados, para variáveis que influenciam um cálculo, para nós de chamadas, etc., combinando passos até compor o padrão desejado. A curva de aprendizado envolve familiarizar-se com os tipos de nós e arestas do CPG (a especificação do grafo) e com a sintaxe Scala/DSL. Para quem já programa, a barreira pode ser menor do que aprender QL do zero, mas entender profundamente o esquema do CPG e as funções utilitárias disponíveis leva tempo. A documentação do Joern fornece um “Reference Card” dos passos disponíveis e tutoriais de consultas básicas e avançadas, o que ajuda na adoção da DSL[\[23\]](https://docs.joern.io/code-property-graph/#:~:text=,27)[\[24\]](https://docs.joern.io/code-property-graph/#:~:text=,Upgrade%20Guide). Em suma, as consultas CodeQL tendem a ser mais declarativas (especificando condições lógicas), enquanto no Joern são mais _navegacionais_ e imperativas (percorrendo o grafo). Cada abordagem tem vantagens: a sintaxe do Joern pode ser mais concisa para certos padrões (e.g., encontrar qualquer chamada cujo argumento seja uma soma, com cpg.call(...).argument.isCallTo("&lt;operator&gt;.addition")[\[25\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=If%20we%20wanted%20to%20hunt,we%20should%20write%20something%20like), em vez de precisar mencionar índices e tipos explicitamente), porém para consultas mais complexas, o CodeQL permite encadear condições logicamente em um só predicado, às vezes de forma mais direta e com menos variáveis temporárias do que um script Joern equivalente[\[15\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=is%20to%20find%20all%20the,overflowing%20memory%20access%20uses%20a)[\[26\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=var%20loop_array_access%20%3D%20cpg.method.controlStructure.parserTypeName%28,ForStatement).

## Suporte a Linguagens de Programação

**Linguagens suportadas pelo CodeQL:** O CodeQL atualmente oferece suporte oficial a uma ampla gama de linguagens populares. Entre elas estão: **C e C++** (padrões C89 até C23, C++98 até C++20+)[\[27\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=C%2FC%2B%2B), **C#** (até versão 10/11 do idioma)[\[28\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=C), **Go**[\[29\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=Go%20), **Java** (versões 7 até 20+, incluindo suporte a Kotlin)[\[30\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=Java)[\[31\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=Kotlin), **JavaScript/TypeScript**[\[32\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=JavaScript)[\[33\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=TypeScript%20), **Python 2 e 3**[\[34\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=Python%20), **Ruby**[\[35\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=Ruby%20), **Rust** (suporte em expansão)[\[36\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=Rust%20) e **Swift**, além de linguagem de configuração do **GitHub Actions (YAML)**[\[37\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=GitHub%20Actions). Ou seja, ele cobre tanto linguagens compiladas de baixo nível quanto linguagens de script e de alto nível. Esse suporte amplo permite rodar consultas de segurança em aplicações _full-stack_ (por exemplo, back-end em Java + front-end em JavaScript) usando uma única plataforma. Vale notar que novas linguagens têm sido adicionadas com o tempo (por exemplo, Rust e Swift tiveram suporte introduzido recentemente em versão beta).

**Linguagens suportadas pelo Joern:** O Joern inicialmente focou em C/C++, mas evoluiu para suportar múltiplas plataformas de código e até binários. De acordo com a documentação oficial, o Joern suporta atualmente análise de código **C e C++**, **JavaScript** (código fonte), **Java** (bytecode via Soot; suporte a código fonte Java em progresso), **Python** (suporte recente/em desenvolvimento), **Kotlin** e **PHP** (também em desenvolvimento), além de **LLVM bitcode** e **executáveis x86 descompilados via Ghidra**[\[38\]](https://joern.io/#:~:text=Uncover%20attack%20surface%2C%20sloppy%20coding,and%20PHP%20support%20coming%20soon). Em outras palavras, o Joern pode construir CPGs tanto de código fonte em linguagens clássicas quanto de representações intermediárias ou binárias. No entanto, comparado ao CodeQL, o conjunto de linguagens plenamente suportadas pelo Joern ainda é **menor**. O foco tem sido C/C++ e linguagens semelhantes; funcionalidades para Python, Java e outras estão “coming soon” ou em estágios iniciais conforme indicado pela documentação[\[38\]](https://joern.io/#:~:text=Uncover%20attack%20surface%2C%20sloppy%20coding,and%20PHP%20support%20coming%20soon). Portanto, em um cenário multi-linguagem abrangente (por exemplo, incluindo C#, Ruby ou Swift), o CodeQL leva vantagem por já ter suporte integrado, enquanto o Joern destaca-se por incluir **análise de código compilado/bibliotecas** (ex.: bitcode, binários) que o CodeQL não cobre diretamente. Cada ferramenta, portanto, atende a um conjunto de linguagens diferente: o CodeQL prioriza cobertura ampla de linguagens de alto nível usadas em aplicações modernas, e o Joern prioriza principalmente código nativo (C/C++ e derivados) e análise de baixo nível.

## Desempenho e Escalabilidade

O desempenho de CodeQL e Joern pode variar bastante dependendo do tamanho do projeto e da infraestrutura disponível, devido às diferenças de arquitetura.

**Tempo de análise e indexação:** Para projetos **pequenos a médios**, ambos os tools apresentam tempos comparáveis para preparar a análise. Um teste informal mostrou cerca de _22 segundos_ para o CodeQL gerar o banco de dados de um projeto pequeno (file utility), contra _19 segundos_ para o Joern processar o mesmo código[\[39\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=to,actual%20time%20to%20get%20CodeQl). Ou seja, em escalas menores não há diferença significativa. Contudo, **em projetos grandes**, as abordagens diferentes pesam: o CodeQL, ao exigir compilação, pode se beneficiar de estruturas de dados otimizadas e menor pegada em memória, enquanto o Joern mantém um grafo em memória que pode crescer enormemente. No experimento com o código completo do **Wireshark** (projeto grande, milhões de linhas em C/C++), o CodeQL levou cerca de **43 minutos** para gerar a base de dados e finalizar a análise, ao passo que o Joern inicialmente ficou sem memória (em uma máquina com 16 GB de RAM) e só conseguiu completar em cerca de **6 horas** quando executado em uma máquina com **128 GB de RAM**[\[40\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=Joern%20operated%20the%20parsing%20in,in%20terms%20of%20dependencies%2C%20compiler)[\[41\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=run%20the%20analyzers%20against%20the,my%20experience%2C%20usually%20it%20is). Esses números indicam que o CodeQL escalou melhor em tempo para esse projeto, enquanto o Joern exigiu uma máquina muito mais robusta para não falhar. Em termos de execução de consultas, o **CodeQL** utiliza um motor de consultas otimizado (compilando as queries para planos eficientes, similares a Datalog/relational algebra) e lida bem com buscas complexas mesmo em bases grandes – embora consultas extremamente pesadas (por exemplo, análise de fluxo de dados interprocedural em toda a codebase) possam demorar horas como visto em alguns casos[\[15\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=is%20to%20find%20all%20the,overflowing%20memory%20access%20uses%20a). Já o **Joern**, tendo todo o grafo na memória, pode responder rápido a consultas interativas simples, mas consultas globais complexas podem ser custosas. No exemplo de uma análise de fluxo de dados interprocedural para detectar um bug de buffer overflow, a abordagem direta **demorou ~4 horas no CodeQL e não terminou no Joern** (o Joern travou antes de concluir)[\[15\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=is%20to%20find%20all%20the,overflowing%20memory%20access%20uses%20a). Ou seja, para certas análises de amplo escopo, o CodeQL demonstrou melhor robustez de performance, enquanto o Joern enfrentou limitações.

**Escalabilidade:** O CodeQL foi projetado com escalabilidade em mente – ele é usado no GitHub para analisar milhares de projetos de código aberto rotineiramente. Seu modelo de _database_ permite até executar consultas em múltiplos repositórios (_variant analysis_ em larga escala) de forma distribuída, já que as consultas rodam independentemente em cada base de dados por linguagem[\[42\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=techniques)[\[43\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=When%20you%20have%20a%20query,analysis%20in%20the%20GitHub%20docs). Além disso, o CodeQL suporta incrementalizar análises em CI (por exemplo, analisando apenas diffs). O Joern, por sua vez, pode ser escalado horizontalmente em parte graças ao conceito de **overlays** e estruturas de grafo eficientes, e há menções a suporte para processamento paralelo do grafo com baixo footprint[\[44\]](https://docs.joern.io/code-property-graph/#:~:text=statement%20and%20expression%20level%2C%20it,ingredient%20for%20scaling%20the%20approach). Contudo, na prática, escalabilidade do Joern frequentemente esbarra no requisito de muita memória RAM para projetos enormes, já que o grafo completo precisa residir acessível para as travessias. A documentação do Joern sugere técnicas de tuning de desempenho (como aumentar heap JVM, fatiar importação por módulos) para lidar com projetos extensos, mas é um ponto de atenção. Em resumo, **em projetos gigantescos**, o CodeQL tende a ser mais viável “out of the box” (desde que se consiga compilar o código), enquanto o Joern pode exigir hardware potente e ajustes para escalar, correndo risco de lentidão ou OOM em análises muito amplas[\[40\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=Joern%20operated%20the%20parsing%20in,in%20terms%20of%20dependencies%2C%20compiler)[\[41\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=run%20the%20analyzers%20against%20the,my%20experience%2C%20usually%20it%20is). Já em projetos médios ou em análises focadas em partes do código (módulos isolados), o Joern pode ser mais ágil por eliminar a sobrecarga de compilação e permitir consultas pontuais rápidas[\[45\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=The%20fact%20that%20CodeQl%20requires,parsing%20of%20the%20source%20code).

## Usabilidade (Curva de Aprendizado, Ferramental e Documentação)

**Curva de aprendizado:** O CodeQL apresenta uma curva de aprendizado inicial relativamente acentuada, pois o analista precisa se familiarizar com a sintaxe QL e com as extensas bibliotecas padrão de cada linguagem. Programadores que já conhecem SQL ou lógica declarativa podem encontrar conceitos familiares, mas ainda assim QL possui suas particularidades (por exemplo, notação de predicados e classes, quantificações implícitas, etc.). A boa notícia é que a comunidade e a documentação são ricas: a GitHub Security Lab oferece tutoriais, jogos interativos e inúmeros exemplos de queries prontas[\[17\]\[18\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=,world%20codebases). Além disso, como o CodeQL é amplamente adotado, existem fóruns, repositórios públicos com queries (por exemplo, as queries open source usadas no code scanning do GitHub) e materiais didáticos que ajudam a reduzir a curva. No caso do Joern, a barreira está em dois aspectos: aprender o **esquema do Code Property Graph** (ou seja, quais tipos de nós e relações existem, como representar certas construções de linguagem no grafo) e dominar a **DSL em Scala**. Usuários sem familiaridade com Scala/Lambda expressions podem precisar de uma introdução à sintaxe (o Joern até fornece um guia “Learning Scala” em sua documentação[\[46\]](https://docs.joern.io/code-property-graph/#:~:text=,39)). Porém, para quem já programa em linguagens orientadas a objeto ou funcionais, escrever consultas como cadeias de métodos pode ser intuitivo após entender os principais passos (cpg.method, filter, out, in, etc.). Em termos de documentação, o Joern possui documentação oficial com exemplos de consultas para sintaxe, travessia de árvore, fluxo de dados, etc., além de um _cheat sheet_ (**Reference Card**) enumerando operações comuns[\[23\]](https://docs.joern.io/code-property-graph/#:~:text=,27)[\[24\]](https://docs.joern.io/code-property-graph/#:~:text=,Upgrade%20Guide). A comunidade do Joern é menor que a do CodeQL, mas existe um Discord oficial e artigos de pesquisa e blog demonstrando seu uso. Em resumo, **nenhuma das duas ferramentas é trivial no primeiro contato**, mas o CodeQL conta com um ecossistema de suporte mais maduro devido à sua popularização via GitHub.

**Ferramentas e Integração com IDEs:** O CodeQL oferece um **plugin oficial para Visual Studio Code** que facilita muito a usabilidade para criação de consultas customizadas[\[47\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=After%20you%E2%80%99ve%20created%20a%20CodeQL,36%20CodeQL%20for%20VS%20Code). Com essa extensão, o usuário pode escrever queries .ql com destaque de sintaxe, autocompletar classes e predicados das bibliotecas padrão, executar as queries localmente contra um banco de dados e ver os resultados diretamente ligados ao código fonte (inclusive com gráficos de fluxo, nos casos de path queries)[\[48\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=After%20you%E2%80%99ve%20created%20a%20CodeQL,%E2%80%9D)[\[7\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=designed%20to%20find). Isso reduz bastante a fricção em iterar na escrita de uma query. Já o Joern é primariamente uma ferramenta de linha de comando e shell interativo. Ele possui um **shell REPL** próprio (que pode ser iniciado via joern no terminal) onde se pode digitar consultas e obter resultados instantâneos[\[49\]](https://docs.joern.io/traversal-basics/#:~:text=A%20First%20Traversal%20)[\[50\]](https://docs.joern.io/traversal-basics/#:~:text=joern,Traversal). Esse modo interativo é ótimo para exploração manual de um código – você pode ir executando passos gradualmente (por exemplo, começar com cpg.method para ver métodos, depois encadear .name, etc.). O Joern não tem integração nativa com IDEs populares para escrever consultas, mas devido à natureza em Scala, é possível usar um IDE (como IntelliJ) para desenvolver _scripts_ ou extensões do Joern se necessário (a documentação traz dicas de configuração de IDE para desenvolvimento de plugins[\[46\]](https://docs.joern.io/code-property-graph/#:~:text=,39)). Em termos de _tooling_, o CodeQL inclui seu CLI (codeql CLI) para criação de bancos de dados e execução de queries por linha de comando ou scripts – útil para automação. O Joern também oferece utilitários CLI como o joern-cli e o comando joern-scan (ver seção CI/CD) para rodar scans automaticamente. Em geral, para uso **ad hoc**, o Joern shell é muito conveniente para navegar no código, enquanto para escrever **consultas complexas repetíveis**, o CodeQL em VS Code com seu tooling fornece uma experiência de desenvolvimento mais robusta (com debugging de queries, profiling, etc., fornecidos pelo engine).

**Documentação e suporte:** O CodeQL tem documentação oficial detalhada no site da GitHub (com guia da linguagem QL, especificações de biblioteca padrão, exemplos de queries por linguagem, etc.), além de blog posts técnicos do Security Lab exemplificando vulnerabilidades encontradas com CodeQL[\[17\]\[18\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=,world%20codebases). O Joern, por sua vez, também possui documentação online abrangente (docs.joern.io) cobrindo desde a instalação, tutoriais básicos, referência da DSL, até conceitos avançados como _CPG overlays_ e criação de análises customizadas[\[51\]](https://docs.joern.io/code-property-graph/#:~:text=,23)[\[23\]](https://docs.joern.io/code-property-graph/#:~:text=,27). A diferença está na maturidade e quantidade de conteúdo externo: CodeQL, sendo amplamente usado, gera mais discussões em comunidades de segurança e repositórios públicos. Em contrapartida, o Joern tem suas raízes na pesquisa acadêmica e uso especializado, então boa parte do conhecimento está em artigos (como o paper original do CPG[\[10\]](https://docs.joern.io/code-property-graph/#:~:text=,flow.)) e nas próprias issues do GitHub do projeto. Ambos os projetos são ativos e mantidos (CodeQL pela GitHub/Microsoft; Joern pela comunidade Qwiet AI), com atualizações frequentes.

## Integração com Pipelines CI/CD e Automação

**CodeQL em CI/CD:** Uma das grandes vantagens do CodeQL é a integração nativa com o **GitHub**. Desde que o CodeQL foi incorporado ao _GitHub Advanced Security_, é extremamente fácil habilitar _Code Scanning_ em repositórios do GitHub – basta configurar um _workflow_ de GitHub Actions usando o action oficial do CodeQL, que a própria plataforma realiza o build, gera a base de dados, executa um conjunto de consultas de segurança predefinidas e reporta alertas na aba de _Security_ do repositório[\[52\]](https://www.tesena.com/en/find-vulnerabilities-in-your-code-with-codeql/a-481/#:~:text=Doing%20security%20analysis%20on%20source,launched%20as%20GitHub%20code%20scanning)[\[53\]](https://www.tesena.com/en/find-vulnerabilities-in-your-code-with-codeql/a-481/#:~:text=When%20GitHub%27s%20code%20scanning%20detects,GitHub%20automatically%20closes%20the%20alert). Isso traz a análise estática para o pipeline de CI de forma contínua: a cada _push_ ou _pull request_, as queries do CodeQL são executadas e potenciais vulnerabilidades são reportadas como resultados (em formato SARIF) dentro do fluxo de desenvolvimento[\[53\]](https://www.tesena.com/en/find-vulnerabilities-in-your-code-with-codeql/a-481/#:~:text=When%20GitHub%27s%20code%20scanning%20detects,GitHub%20automatically%20closes%20the%20alert)[\[54\]](https://www.tesena.com/en/find-vulnerabilities-in-your-code-with-codeql/a-481/#:~:text=What%20can%20CodeQL%20detect%3F). Para quem não usa GitHub ou quer integrar em outros sistemas, o CodeQL CLI pode ser invocado em scripts de CI (Jenkins, GitLab CI, Azure DevOps, etc.): você incluiria etapas de “gerar CodeQL database” e “rodar queries” no pipeline, e então processaria os resultados (o CodeQL gera resultados em formatos como SARIF, que podem ser consumidos por outras ferramentas)[\[5\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=After%20you%E2%80%99ve%20created%20a%20CodeQL,36%20CodeQL%20for%20VS%20Code)[\[7\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=designed%20to%20find). Organizações que adotam GitHub Enterprise também podem usar CodeQL scanning como parte do fluxo de DevSecOps. Assim, o CodeQL se encaixa bem em pipelines, automatizando a detecção de falhas de segurança a cada build/commit. Vale notar que por ser amplamente suportado e ter licenciamento gratuito para projetos open-source, muitas ferramentas de integração já reconhecem CodeQL.

**Joern em CI/CD:** O Joern não está integrado em nenhuma plataforma de repositório de forma nativa, mas ele foi pensado para automação flexível. Existe um comando específico, o joern-scan, que permite **executar scanners de código pré-definidos** de forma não interativa – ideal para CI. O joern-scan já vem com múltiplos _scanners_ implementados para C/C++, que englobam checagens de complexidade de código, detecção de buffer overflows, uso inseguro de funções comuns, entre outras coisas[\[55\]](https://joern.io/automate/#:~:text=So%2C%20what%E2%80%99s%20under%20the%20hood%3F). Basta apontá-lo para um diretório de código (joern-scan ~/meuProjeto) que ele processa o código, roda esses scanners (conjunto de queries bundladas) e imprime um relatório dos achados[\[56\]](https://joern.io/automate/#:~:text=Run%20%60joern)[\[55\]](https://joern.io/automate/#:~:text=So%2C%20what%E2%80%99s%20under%20the%20hood%3F). Esse resultado pode então ser coletado no log do pipeline para análise ou falha de build se necessário. Assim, é relativamente fácil adicionar Joern em um pipeline: e.g., em um job do CI você pode instalar o Joern (script de instalação disponível via shell) e executar joern-scan, integrando isso ao fluxo de build/test. Além disso, o Joern pode ser usado de forma programática: a própria ferramenta divulga que você pode usá-la como uma **biblioteca ou via REST API** para alimentar suas próprias ferramentas de análise[\[57\]](https://joern.io/#:~:text=Integrate). Em um cenário avançado, uma equipe poderia escrever consultas Joern customizadas e incorporá-las em um serviço interno (usando a API REST do Joern Server ou incluindo o Joern como dependência em um projeto Scala/Java) para verificar código automaticamente a cada push. Em suma, embora falte a conveniência de um _one-click_ setup como o CodeQL no GitHub, o Joern oferece mecanismos (CLI e API) para integração personalizada em CI/CD. De fato, o site oficial encoraja a criar scanners customizados e **rodá-los no CI** usando Joern[\[58\]](https://joern.io/#:~:text=Automate). Um possível uso é combinar o Joern com ferramentas de pipeline existentes: por exemplo, rodar Joern-scan e converter sua saída para um formato de relatório que possa ser consumido (alguns usuários adaptam a saída para SARIF ou outros formatos de análise estática para integração com dashboards).

## Foco em Segurança e Cobertura de Vulnerabilidades

Tanto o CodeQL quanto o Joern são pensados para **análise de segurança de código**, porém há diferenças em foco e cobertura “out-of-the-box”.

**CodeQL:** A orientação do CodeQL sempre foi identificar vulnerabilidades de forma **abrangente** em diversas linguagens. A biblioteca padrão do CodeQL (e os pacotes de queries disponibilizados pelo GitHub) cobrem uma vasta gama de categorias de falhas de segurança. Por exemplo, o CodeQL possui queries que detectam **injection flaws** (SQL Injection, Command Injection), **Cross-Site Scripting (XSS)**, uso inseguro de bibliotecas criptográficas, divulgação indevida de informações sensíveis, problemas de autenticação/autorização, **Insecure Direct Object References**, etc.[\[59\]](https://www.tesena.com/en/find-vulnerabilities-in-your-code-with-codeql/a-481/#:~:text=Issues%20CodeQL%20can%20identify%3A)[\[60\]](https://www.tesena.com/en/find-vulnerabilities-in-your-code-with-codeql/a-481/#:~:text=malicious%20sites,depending%20on%20the%20programming%20language). Em JavaScript/TypeScript, há regras para identificar possíveis XSS, injeções de SQL/NoSQL, deserialização insegura, etc. Em linguagens backend (Java, C#, Go), existem queries para SQL injection, LDAP injection, path traversal, leaks de log, e assim por diante. Em C/C++, o CodeQL tem muitas regras voltadas a **erros de memória** (buffer overflows, _use-after-free_, double close, integer overflow se levando a overflow de buffer, uso inseguro de funções como strcpy ou gets etc.) e também lógica de ponteiros, condições de corrida, e problemas de API (por ex., esquecER de verificar retorno de funções de alocação). Muitas dessas queries foram escritas pela comunidade e pelo Security Lab, aproveitando o poder do CodeQL de combinar análise de fluxo de dados com conhecimento semântico da linguagem. Um destaque é a capacidade de fazer **variant analysis**: dado um exemplo de vulnerabilidade (um “seed”), o analista pode escrever ou adaptar uma query CodeQL para achar instâncias similares no código atual ou até em todos os repositórios de uma organização[\[61\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=CodeQL%20is%20a%20language%20and,them%20into%20their%20development%20workflows)[\[62\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=Variant%20analysis%20is%20the%20process,properly%20fixed%20across%20multiple%20codebases). Essa prática é muito utilizada pelo GitHub Security Lab para encontrar variantes da mesma falha em projetos diferentes (por exemplo, após descobrir uma falha em um projeto open source, rodar a query em milhares de outros projetos para achar ocorrências semelhantes). Em resumo, o CodeQL tem **forte foco em segurança generalista** – atende desde falhas web comuns (OWASP Top 10) até vulnerabilidades de baixo nível – e seus pacotes de consulta recebem atualizações frequentes conforme novas categorias de falhas surgem ou pesquisas identificam novos padrões de ataque[\[59\]](https://www.tesena.com/en/find-vulnerabilities-in-your-code-with-codeql/a-481/#:~:text=Issues%20CodeQL%20can%20identify%3A)[\[60\]](https://www.tesena.com/en/find-vulnerabilities-in-your-code-with-codeql/a-481/#:~:text=malicious%20sites,depending%20on%20the%20programming%20language). Importante ressaltar: o CodeQL em si não “descobre automaticamente” vulnerabilidades – ele destaca padrões inseguros conforme definido pelas queries. Mas a comunidade já fornece uma vasta cobertura desses padrões, que organizações podem utilizar imediatamente.

**Joern:** O Joern nasceu no contexto de pesquisa em vulnerabilidades (a ideia original do CPG era encontrar bugs em código C, como no kernel Linux[\[10\]](https://docs.joern.io/code-property-graph/#:~:text=,flow.)) e por isso tem um **foco forte em vulnerabilidades de softwares de baixo nível**. As consultas e scanners fornecidos com o Joern (especialmente para C/C++) concentram-se em problemas clássicos de segurança de sistemas: **buffer overflows (heap e stack)**, **integer overflows** (que possam levar a erros de alocação), uso de funções perigosas (_unsafe functions_ como strcpy, strncpy, sprintf sem checar tamanhos)[\[55\]](https://joern.io/automate/#:~:text=So%2C%20what%E2%80%99s%20under%20the%20hood%3F), aritmética de ponteiros arriscada, condições de off-by-one, exposições de memória, etc. Por exemplo, um dos scanners padrão do joern-scan detecta casos de possíveis _heap overflow_ quando o tamanho alocado é influenciado por uma operação aritmética e depois um memcpy copia mais bytes do que o alocado – padrão que pode indicar um erro de cálculo de buffer[\[63\]](https://joern.io/automate/#:~:text=Heap%20Based%20Buffer%20Overflow)[\[64\]](https://joern.io/automate/#:~:text=1,the%20first%20argument%20of%20malloc). Esse tipo de verificação demonstra o nível de detalhe do foco do Joern em segurança de memória. Além disso, o Joern facilita muito a busca por **padrões de código específicos** que podem ser vulneráveis. Por exemplo, um pesquisador pode rapidamente fazer consultas para localizar “todas chamadas de função X onde o parâmetro Y vem de fonte externa não validada” ou “todas comparações de tamanho antes de uma cópia de buffer”. A força do Joern está em análises customizadas e interativas – ideal para um _bug hunter_ explorar uma base procurando variantes de um bug manualmente descoberto. Com a adição de suporte a outras linguagens, o Joern potencialmente cobre também falhas nessas: por exemplo, com suporte a Java e Python, pode-se escrever queries para achar vulnerabilidades web (XSS, injection) nessas linguagens. No entanto, diferentemente do CodeQL, o Joern **não vem ainda com um grande repositório de regras de alto nível para todas as linguagens**. A cobertura pronta é mais limitada. Em C/C++, as scanners do Joern cobrem diversos casos conhecidos (como mencionado). Já para JavaScript, Python etc., como o suporte é recente, o usuário provavelmente terá que criar suas próprias queries para achar coisas como XSS ou injeções, pois a comunidade do Joern nesses ecossistemas é menor. Portanto, podemos dizer que o Joern tem foco profundo em segurança de código _low-level_ e vulnerabilidades de memória/dados, sendo excelente para encontrar padrões de exploração em código de sistema, kernel, drivers, aplicações em C/C++. O CodeQL, por sua vez, cobre tanto essa parte (memória, em C/C++) quanto toda a esfera de segurança de aplicações de alto nível. Em suma: **vulnerabilidades de buffer overflow, arithmetic bugs e outros erros de implementação em C/C++ são bem atendidos por ambos, mas com Joern oferecendo talvez mais flexibilidade exploratória**, enquanto **vulnerabilidades em aplicações web, bancos de dados, APIs REST, etc., são território onde o CodeQL brilha devido à sua biblioteca de regras já existente**[\[59\]](https://www.tesena.com/en/find-vulnerabilities-in-your-code-with-codeql/a-481/#:~:text=Issues%20CodeQL%20can%20identify%3A).

## Exemplos de Cenários de Uso e Recomendações

Considerando todas as características acima, podemos delinear alguns cenários em que uma ferramenta pode ser **mais indicada** que a outra:

- **Análise de projeto grande e complexo (muitas linhas, múltiplos módulos):** Se o projeto é enorme (por exemplo, um kernel ou um grande aplicativo com milhões de LOC) e especialmente se é viável montá-lo/compilá-lo, o **CodeQL** tende a ser a melhor escolha. Ele lida melhor com escala, tanto em performance quanto em organização da análise. No caso de precisar analisar o _projeto inteiro_ com abrangência, CodeQL provavelmente será mais eficiente e prático[\[65\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=take%20more%20time%20to%20guess,parsing%20of%20the%20source%20code). Já se for necessário extrair informação sem conseguir compilar (por falta de dependências ou build complicado), o Joern pode quebrar um galho parseando o código “como está”; porém, para abranger todo o código, possivelmente demandará máquinas muito potentes para segurar o grafo completo.
- **Análise parcial ou exploratória de código (módulo específico, código incompleto):** Aqui o **Joern** se destaca. Como ele não requer configuração de build, é excelente para _“minerar”_ partes de um código sem montar todo o ambiente. Por exemplo, se você quer analisar apenas o módulo de autenticação de um software grande, pode apontar o Joern para aquele diretório e rapidamente navegar pelo CPG buscando padrões[\[45\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=The%20fact%20that%20CodeQl%20requires,parsing%20of%20the%20source%20code). Pesquisadores frequentemente usam o Joern para auditorias rápidas de repositórios open-source: clonar o repo, importar no Joern e interativamente procurar por funções perigosas, flows de dados suspeitos, etc. Esse uso iterativo é mais fluido no Joern que no CodeQL, que exigiria compilar todo o projeto ou configurar queries específicas e gerar DBs. Em resumo, para _slicing_ e consultas ad-hoc num subset do código, o Joern é indicado.
- **Projetos em múltiplas linguagens (ecosistema variado):** O **CodeQL** leva vantagem por suportar diversas linguagens em um só fluxo. Se seu projeto tem, por exemplo, front-end JavaScript, back-end Java, um módulo em Go e um componente nativo em C++, o CodeQL consegue analisar cada parte (gerando um DB para cada linguagem) e você pode até escrever queries multi-linguagem (limitado, mas possível correlacionar alguns dados) ou pelo menos usar uma única ferramenta para todos. O Joern, no estado atual, não cobriria todas essas linguagens juntas – faltaria suporte a algumas e as consultas teriam que ser feitas separadamente por linguagem com DSLs possivelmente diferentes. Portanto, em contextos _polyglot_ ou enterprise com muitas linguagens, CodeQL é mais adequado.
- **Integração DevSecOps em pipeline corporativo:** Se o objetivo é incorporar análises automatizadas de segurança no pipeline de desenvolvimento de forma contínua, o **CodeQL** é geralmente a opção mais direta. Especialmente para quem usa GitHub, a integração é trivial (CodeQL code scanning). Mesmo fora do GitHub, o suporte da CLI e o formato de saída padrão (SARIF) tornam-no mais fácil de integrar a sistemas de alerte e dashboards existentes. O Joern pode ser usado em CI, mas exigirá um pouco mais de trabalho manual para instalar e interpretar resultados. Uma exceção seria se a empresa lida predominantemente com C/C++ e deseja rodar scanners customizados – aí um _joern-scan_ custom no CI poderia suprir bem, mas ainda assim o CodeQL fornece muitas das mesmas verificações já prontas. Em organizações que valorizam software open-source e customização, o Joern sendo totalmente aberto e extensível via código pode ser atraente para construir uma solução sob medida (por exemplo, uma pipeline interna que use a API do Joern para verificar padrões específicos do código da empresa).
- **Pesquisa de vulnerabilidades e _variant analysis_ manual:** Ambos os tools servem para varredura de variantes, mas a preferência pode depender do contexto. Se você já identificou uma vulnerabilidade num projeto C/C++ e quer achar variantes _no mesmo projeto ou em projetos similares_, o **Joern** permite iterar rapidamente, ajustando consultas no REPL até isolar o padrão exato, especialmente se não precisar analisar além daquele codebase. Por outro lado, se você quer encontrar variantes do mesmo bug em **centenas de projetos diferentes**, o **CodeQL** oferece o mecanismo de análise em larga escala (multi-repo) e a infraestrutura (via GitHub or CLI scripts) para orquestrar isso[\[42\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=techniques)[\[43\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=When%20you%20have%20a%20query,analysis%20in%20the%20GitHub%20docs). Por exemplo, após descobrir um bug em uma biblioteca Java, você pode escrever uma query CodeQL e rodar no _LGTM.com_ ou em lotes de repositórios no GitHub to flag the same bug elsewhere – algo já feito em diversos casos reportados no Security Lab blog.
- **Análise de código compilado ou sem código fonte disponível:** Aqui o **Joern** é praticamente a única opção dos dois. Se você tem um binário x86 ou bytecode LLVM e suspeita de vulnerabilidades, pode usar a integração do Joern com o Ghidra (para decompilar binários para CPG) ou com o Soot (bytecode JVM) para gerar um grafo e então analisar. O CodeQL não oferece análise de binários – ele requer fonte ou, no máximo, bytecode IL de .NET se suportado indiretamente via C#. Portanto, para cenários de _reverse engineering_ estático focado em segurança, o Joern é mais indicado. Um exemplo real: pesquisadores já utilizaram Joern para analisar binários maliciosos ou firmware compilado, construindo o grafo e consultando por padrões de comportamento. Se o código-fonte não compila mais (ex.: pseudocódigo de decompiler), CodeQL não conseguiria processar, enquanto o Joern, com parseamento permissivo, poderia extrair o CPG mesmo assim[\[66\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=A%20particularly%20interesting%20use%20case,better%20doability%20of%20the%20approach).
- **Cobertura de vulnerabilidades específicas:** Se a preocupação principal são vulnerabilidades web/app em linguagens gerenciadas (Java, C#, Python, JS), o **CodeQL** possui imediatamente uma maior gama de regras de detecção – por exemplo, identificar XSS em um aplicativo Node.js ou injection em um código Python Django – então ele se torna a escolha prática. Por outro lado, se o foco é auditar um projeto C/C++ crítico (por exemplo, um servidor em C++ ou um componente de sistema operacional) em profundidade, ambos podem ser usados, mas o **Joern** pode dar mais **liberdade exploratória** para o analista procurar padrões não previstos. Exemplificando: o CodeQL encontrará muitas falhas conhecidas automaticamente, mas talvez você queira procurar um antipadrão específico que não haja query pronta – no CodeQL você teria que escrever uma query QL (o que é possível, claro), e no Joern você poderia interativamente montar essa lógica navegando pelo grafo. Pesquisadores avançados às vezes usam as duas ferramentas em tandem: o CodeQL para um _scan_ amplo inicial (pegando problemas óbvios), e depois o Joern para fuçar em busca de bugs lógicos ou cadeias específicas.

**Conclusão:** CodeQL e Joern são ferramentas **complementares** mais do que estritamente concorrentes. O CodeQL se destaca pelo **ecossistema robusto, amplo suporte de linguagens e integração**, sendo ideal para incorporação em fluxos de desenvolvimento e para garantir segurança de forma contínua em projetos grandes (é muitas vezes a escolha para _enterprise scanning_ ou para projetos open source via GitHub)[\[67\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=recent%20work%20based%20on%20Joern%2FCodeQl,size%20codebases.%20In%20contrast)[\[68\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=game%20in%20the%20end%2C%20but,are%20already%20two%20mature%20frameworks). O Joern brilha como o **“workbench” do caçador de bugs** – flexível, permite olhar qualquer canto do código rapidamente, aceita código incompilável, e foca em detalhes de implementação, o que o torna favorito em pesquisas de vulnerabilidades em C/C++ de médio porte ou análises pontuais[\[45\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=The%20fact%20that%20CodeQl%20requires,parsing%20of%20the%20source%20code)[\[67\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=recent%20work%20based%20on%20Joern%2FCodeQl,size%20codebases.%20In%20contrast). Não há um “vencedor” universal entre os dois; a melhor escolha depende do contexto. Muitas equipes podem até usar ambos: CodeQL para segurança automatizada contínua e Joern para investigações manuais e análises profundas onde necessário. Em qualquer caso, ambos os frameworks são exemplos de como tratar código fonte como dados consultáveis, elevando o patamar da detecção de vulnerabilidades de forma significativa.

**Referências:**

- Documentação oficial do CodeQL (GitHub)[\[69\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=To%20create%20a%20database%2C%20CodeQL,source%20file%20in%20the%20codebase)[\[70\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=After%20you%E2%80%99ve%20created%20a%20CodeQL,36%20CodeQL%20for%20VS%20Code); Documentação oficial do Joern (Qwiet AI)[\[19\]](https://docs.joern.io/code-property-graph/#:~:text=The%20code%20property%20graph%20is,and%20its%20commercial%20brother%20Ocular)[\[13\]](https://docs.joern.io/code-property-graph/#:~:text=Property%20graphs%20are%20a%20generic,our%20own%20graph%20database%20OverflowDB).
- Análise comparativa de desempenho e usabilidade por Elmanto (2023)[\[1\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=On%20the%20one%20hand%2C%20CodeQl,for%20further%20processing%20and%20querying)[\[39\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=to,actual%20time%20to%20get%20CodeQl)[\[40\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=Joern%20operated%20the%20parsing%20in,in%20terms%20of%20dependencies%2C%20compiler)[\[45\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=The%20fact%20that%20CodeQl%20requires,parsing%20of%20the%20source%20code).
- Artigos e blogs sobre usos de CodeQL em segurança (GitHub Security Lab, Tesena)[\[59\]](https://www.tesena.com/en/find-vulnerabilities-in-your-code-with-codeql/a-481/#:~:text=Issues%20CodeQL%20can%20identify%3A)[\[60\]](https://www.tesena.com/en/find-vulnerabilities-in-your-code-with-codeql/a-481/#:~:text=malicious%20sites,depending%20on%20the%20programming%20language) e sobre funcionalidades do Joern (post “Automatic Scans”, joern.io)[\[55\]](https://joern.io/automate/#:~:text=So%2C%20what%E2%80%99s%20under%20the%20hood%3F)[\[64\]](https://joern.io/automate/#:~:text=1,the%20first%20argument%20of%20malloc).

[\[1\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=On%20the%20one%20hand%2C%20CodeQl,for%20further%20processing%20and%20querying) [\[9\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=With%20a%20completely%20different%20perspective%2C,memory) [\[15\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=is%20to%20find%20all%20the,overflowing%20memory%20access%20uses%20a) [\[16\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=Here%2C%20I%20show%20the%20query,written%20for%20CodeQl) [\[25\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=If%20we%20wanted%20to%20hunt,we%20should%20write%20something%20like) [\[26\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=var%20loop_array_access%20%3D%20cpg.method.controlStructure.parserTypeName%28,ForStatement) [\[39\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=to,actual%20time%20to%20get%20CodeQl) [\[40\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=Joern%20operated%20the%20parsing%20in,in%20terms%20of%20dependencies%2C%20compiler) [\[41\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=run%20the%20analyzers%20against%20the,my%20experience%2C%20usually%20it%20is) [\[45\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=The%20fact%20that%20CodeQl%20requires,parsing%20of%20the%20source%20code) [\[65\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=take%20more%20time%20to%20guess,parsing%20of%20the%20source%20code) [\[66\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=A%20particularly%20interesting%20use%20case,better%20doability%20of%20the%20approach) [\[67\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=recent%20work%20based%20on%20Joern%2FCodeQl,size%20codebases.%20In%20contrast) [\[68\]](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql#:~:text=game%20in%20the%20end%2C%20but,are%20already%20two%20mature%20frameworks) The Derby of Static Software Testing: Joern vs. CodeQl | elmanto.github.io

<https://elmanto.github.io/posts/sast_derby_joern_vs_codeql>

[\[2\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=For%20compiled%20languages%2C%20extraction%20works,name%20binding%20and%20type%20information) [\[3\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=CodeQL%20databases%20contain%20queryable%20data,and%20the%20control%20flow%20graph) [\[4\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=For%20each%20language%2C%20the%20CodeQL,it%20easier%20to%20write%20queries) [\[5\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=After%20you%E2%80%99ve%20created%20a%20CodeQL,36%20CodeQL%20for%20VS%20Code) [\[6\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=language%20called%20QL,%E2%80%9D) [\[7\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=designed%20to%20find) [\[17\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=,world%20codebases) [\[18\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=,world%20codebases) [\[42\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=techniques) [\[43\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=When%20you%20have%20a%20query,analysis%20in%20the%20GitHub%20docs) [\[47\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=After%20you%E2%80%99ve%20created%20a%20CodeQL,36%20CodeQL%20for%20VS%20Code) [\[48\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=After%20you%E2%80%99ve%20created%20a%20CodeQL,%E2%80%9D) [\[61\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=CodeQL%20is%20a%20language%20and,them%20into%20their%20development%20workflows) [\[62\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=Variant%20analysis%20is%20the%20process,properly%20fixed%20across%20multiple%20codebases) [\[69\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=To%20create%20a%20database%2C%20CodeQL,source%20file%20in%20the%20codebase) [\[70\]](https://codeql.github.com/docs/codeql-overview/about-codeql/#:~:text=After%20you%E2%80%99ve%20created%20a%20CodeQL,36%20CodeQL%20for%20VS%20Code) About CodeQL — CodeQL

<https://codeql.github.com/docs/codeql-overview/about-codeql/>

[\[8\]](https://blog.xaviermaso.com/2024/08/14/Solving-LinkedIn's-Queens-game-with-CodeQL.html#:~:text=blog%20blog,used%20as%20a%20query) Solving LinkedIn's Queens game with CodeQL - pamplemousse's blog

<https://blog.xaviermaso.com/2024/08/14/Solving-LinkedIn's-Queens-game-with-CodeQL.html>

[\[10\]](https://docs.joern.io/code-property-graph/#:~:text=,flow.) [\[11\]](https://docs.joern.io/code-property-graph/#:~:text=,declaration%20of%20a%20local%20variable) [\[12\]](https://docs.joern.io/code-property-graph/#:~:text=%2A%20Key,type%20of%20the%20declared%20variable) [\[13\]](https://docs.joern.io/code-property-graph/#:~:text=Property%20graphs%20are%20a%20generic,our%20own%20graph%20database%20OverflowDB) [\[19\]](https://docs.joern.io/code-property-graph/#:~:text=The%20code%20property%20graph%20is,and%20its%20commercial%20brother%20Ocular) [\[23\]](https://docs.joern.io/code-property-graph/#:~:text=,27) [\[24\]](https://docs.joern.io/code-property-graph/#:~:text=,Upgrade%20Guide) [\[44\]](https://docs.joern.io/code-property-graph/#:~:text=statement%20and%20expression%20level%2C%20it,ingredient%20for%20scaling%20the%20approach) [\[46\]](https://docs.joern.io/code-property-graph/#:~:text=,39) [\[51\]](https://docs.joern.io/code-property-graph/#:~:text=,23) Code Property Graph | Joern Documentation

<https://docs.joern.io/code-property-graph/>

[\[14\]](https://www.tesena.com/en/find-vulnerabilities-in-your-code-with-codeql/a-481/#:~:text=that%20triggered%20the%20alert%2C%20GitHub,automatically%20closes%20the%20alert) [\[52\]](https://www.tesena.com/en/find-vulnerabilities-in-your-code-with-codeql/a-481/#:~:text=Doing%20security%20analysis%20on%20source,launched%20as%20GitHub%20code%20scanning) [\[53\]](https://www.tesena.com/en/find-vulnerabilities-in-your-code-with-codeql/a-481/#:~:text=When%20GitHub%27s%20code%20scanning%20detects,GitHub%20automatically%20closes%20the%20alert) [\[54\]](https://www.tesena.com/en/find-vulnerabilities-in-your-code-with-codeql/a-481/#:~:text=What%20can%20CodeQL%20detect%3F) [\[59\]](https://www.tesena.com/en/find-vulnerabilities-in-your-code-with-codeql/a-481/#:~:text=Issues%20CodeQL%20can%20identify%3A) [\[60\]](https://www.tesena.com/en/find-vulnerabilities-in-your-code-with-codeql/a-481/#:~:text=malicious%20sites,depending%20on%20the%20programming%20language) Find vulnerabilities in your code with CodeQL | Tesena

<https://www.tesena.com/en/find-vulnerabilities-in-your-code-with-codeql/a-481/>

[\[20\]](https://docs.joern.io/traversal-basics/#:~:text=As%20an%20example%2C%20the%20query) [\[49\]](https://docs.joern.io/traversal-basics/#:~:text=A%20First%20Traversal%20) [\[50\]](https://docs.joern.io/traversal-basics/#:~:text=joern,Traversal) Traversal Basics | Joern Documentation

<https://docs.joern.io/traversal-basics/>

[\[21\]](https://joern.io/automate/#:~:text=val%20src%20%3D%20cpg.call%28,hasNext) [\[22\]](https://joern.io/automate/#:~:text=.call%28,hasNext) [\[55\]](https://joern.io/automate/#:~:text=So%2C%20what%E2%80%99s%20under%20the%20hood%3F) [\[56\]](https://joern.io/automate/#:~:text=Run%20%60joern) [\[63\]](https://joern.io/automate/#:~:text=Heap%20Based%20Buffer%20Overflow) [\[64\]](https://joern.io/automate/#:~:text=1,the%20first%20argument%20of%20malloc) Joern - The Bug Hunter's Workbench | Automatic Scans. On desktop, and in your CI.

<https://joern.io/automate/>

[\[27\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=C%2FC%2B%2B) [\[28\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=C) [\[29\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=Go%20) [\[30\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=Java) [\[31\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=Kotlin) [\[32\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=JavaScript) [\[33\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=TypeScript%20) [\[34\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=Python%20) [\[35\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=Ruby%20) [\[36\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=Rust%20) [\[37\]](https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/#:~:text=GitHub%20Actions) Supported languages and frameworks — CodeQL

<https://codeql.github.com/docs/codeql-overview/supported-languages-and-frameworks/>

[\[38\]](https://joern.io/#:~:text=Uncover%20attack%20surface%2C%20sloppy%20coding,and%20PHP%20support%20coming%20soon) [\[57\]](https://joern.io/#:~:text=Integrate) [\[58\]](https://joern.io/#:~:text=Automate) Joern - The Bug Hunter's Workbench

<https://joern.io/>
